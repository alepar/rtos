			.include "m168Pdef.inc"	; Используем ATMega8

                        .include "config.asm"
			.include "define.asm"	; Наши все определения переменных тут
			.include "macro.asm"	; Все макросы у нас тут



;============SSEG=============================================================
			.DSEG
Mode:		.byte					1		; Переменная режима отображения
			.equ	m_Normal	=0			; Показ логотипа
			.equ	m_Terminal	=1			; Показ минитерминала
			.equ	m_ADC		=2			; Показ данных АЦП
			.equ	m_Button	=3			; Показ имени нажатой кнопки

ADC_Data:	.byte					1		; Тут складируются данные АЦП
ADC_OLD:	.byte					1		; Тут хранится предыдущее значение данных АЦП

ADC_DIG0:	.byte					1		; В этих трех ячейках хранятся ASCII коды
ADC_DIG1:	.byte					1		; данных из АЦП, подготовленные к выводу на экран
ADC_DIG2:	.byte					1		; 

Pressed_B:	.byte					1		; В этой переменной хранится имя последней нажатой клавиши

UDR_I:		.byte					1		; Принятый байт 

; Очереди операционной системы
			.equ TaskQueueSize 		= 20				; Размер очереди задач
TaskQueue: 	.byte					TaskQueueSize 		; Адрес очереди задач в SRAM
			
			.equ TimersPoolSize 	= 20				; Количество таймеров
TimersPool:	.byte 					TimersPoolSize*3	; Адреса информации о таймерах (очередь)


;===========CSEG==============================================================
			.include "vectors.asm"	; Все вектора прерываний спрятаны в этом файле

			.ORG	INT_VECTORS_SIZE		; Конец таблицы прерываний


;=============================================================================!
; Interrupts procs ===========================================================!
;=============================================================================!
; Output Compare 2 interrupt 
; Main Timer Service - Служба Таймеров Ядра РТОС - Обработчик прерывания
OutComp2Int:
			TimerService				; Служба таймера RTOS 
			RETI						; выходим из прерывания

;.............................................................................

;Прерывания от пришедшего байта в UART
RX_OK:		PUSH 	OSRG
			IN 		OSRG,SREG			; Save Sreg
			PUSH 	OSRG

			LDS		OSRG,UDR0
			STS		UDR_I,OSRG

;			SetTask			TS_Terminal

			POP 	OSRG				; Восстанавливаем регистры
			OUT 	SREG,OSRG			; 
			POP 	OSRG
			RETI						; Выходим из прерывания
;=============================================================================!
; Main code ==================================================================!
;=============================================================================!
Reset:		OUTI 	SPL,low(RAMEND) 		; Первым делом инициализируем стек
			OUTI	SPH,High(RAMEND)								

			.include "init.asm"				; Все инициализации тут.


; Запуск фоновых процессов
Background:	
			RCALL	Send				; Отсыл байт в UART 
			

Main:		SEI								; Разрешаем прерывания.

			wdr								; Reset Watch DOG (Если не "погладить" "собаку". то она устроит конец света в виде reset для процессора)
			rcall 	ProcessTaskQueue		; Обработка очереди процессов
			rcall 	Idle					; Простой Ядра
											
			RJMP 	Main					; Основной цикл микроядра РТОС

;=============================================================================
;Tasks
;=============================================================================
Idle:		RET		; Простой ядра. Не используется

;-----------------------------------------------------------------------------
; Задача отсылки данных через терминал. Раз в 50мс шлет байт который считало АЦП
Send:		SetTimerTask	TS_Send,50		; Самозацикливаем задачу через диспетчер таймеров

			LDS		OSRG,ADC_Data			; Загрузить байт из переменной ADC_DATA
			sts		UDR0,OSRG				; Отправить его через USART 
			RET
;-----------------------------------------------------------------------------			

EX_F:		RET							; Выход из задачи

CopySTR:	LPM		OSRG,Z+				; Процедура копирования из флеша в ОЗУ
			ST		Y+,OSRG				; Берет байт по индексу Z и грузит его в ячейки
			DEC		Counter				; По индексу Y. При этом автоматом инкрементируется индекс
			BRNE	CopySTR				; И вручную счетчик байтов в регистре Counter 
			RET

;-----------------------------------------------------------------------------
; ЗАдача сброса в дефолт спустя 5 секунд бездействия
SetDefMode:	SetTimerTask	TS_SetDefMode,5000 		; Самозацикливание задачи через диспетчер таймеров
			STSI	Mode,0							; Сброс режима в 0 - нормальный режим, показ заставки
;			SetTask	TS_Draw							; Постановка на конвеер задачи перерисовки экрана
			RET
;-----------------------------------------------------------------------------
; Задача проверки состояния значений АЦП - не изменились ли?
CheckADC:	SetTimerTask	TS_CheckADC,100		; Вначале самозациклимся на 100мс

			LDS		OSRG,ADC_OLD				; Берем предыдущее значение АЦП
			LDS		ACC,ADC_DATA				; Берем последнее значение АЦП

			ANDI	ACC,0b11110000				; Отрезаем вечно меняющиеся младшие биты. Нам нужны только крупные изменения
			STS		ADC_OLD,ACC					; И текущее обрезанное значение записываем в старое значение

			CP		ACC,OSRG					; Сравниваем текущее значение с заранее взятым старым.

			BREQ	EX_CA						; Если значение не изменилось, то выходим.	

			SetTask			TS_Convert			; А если изменилось, то запускаем задачу конвертации показаний АЦП

EX_CA:		RET
;-----------------------------------------------------------------------------
; Эта задача берет байт показаний АЦП и превращает его в три байта ASCII кодов пригодных для вывода на дисплей
Convert:	LDS		R16,ADC_DATA		; Берем то самое значение

			RCALL	Hex2Ascii			; Вызываем функцию конвертации (она в файле Math\hex2ascii.asm)
			
			STS		ADC_DIG0,R16		; И результат нычим в переменные разрядов, которые потом загребет
			STS		ADC_DIG1,R17		; задача DRAW
			STS		ADC_DIG2,R18

			STSI	Mode,m_ADC			; Попутно обьявим что на ближайшие 2секунды у нас режим АЦП

			SetTimerTask	TS_SetDefMode,2000	; отложим сброс в дефолтный режим
;			SetTask			TS_Draw				; И вызовем через диспетчер обновление видеопамяти

			RET
;-----------------------------------------------------------------------------
; Тут все просто - сканируется клавиатура 10 раз в секунду, каждые 100мс
ScanButton:	SetTimerTask	TS_ScanButton,100		; Задача естественно зациклена через диспетчер таймеров
			CLR		OSRG							; Сбрасываем рабочий регистр

			SBIS	BTA_N,BTA						; И проверяем биты кнопок
			LDI		OSRG,'A'						; Если нажата кнопка, то записываем в OSRG

			SBIS	BTB_N,BTB
			LDI		OSRG,'B'

			SBIS	BTC_N,BTC
			LDI		OSRG,'C'

			SBIS	BTD_N,BTD
			LDI		OSRG,'D'

			CPI		OSRG,0		; Если кнопка ни одна не нажата, то на выходе в OSRG 0
			BREQ	SB_EX		; Грустно выходим					

			STS		Pressed_B,OSRG		; А если нажата, то сохраняем ее в ОЗУ
			STSI	Mode,m_Button		; Ставим режим "Клавиатура"
			
			SetTimerTask	TS_SetDefMode,2000	; Отменяем сброс в дефолт на 2секунды
;			SetTask			TS_Draw				; Перерисовываем видеопамять.

SB_EX:		RET									; Выход из задачи

;=============================================================================
; RTOS Here
;=============================================================================
; Это область определения адресов и индексов задач. Порядок должен быть одинаковым, от этого
; критично зависит работа ОС

			.include "kernel_def.asm"	; Подключаем настройки ядра
			.include "kernel.asm"		; Подклчюаем ядро ОС

; Индексы (номера) задач.
			.equ TS_Idle 			= 0
			.equ TS_Send 			= 1
			.equ TS_SetDefMode		= 2
			.equ TS_CheckADC	 	= 3
			.equ TS_Convert	 		= 4
			.equ TS_ScanButton		= 5


; А это их адреса во флеше. ПО индексу вычисляется смещение в таблице адресов и происходит 
; Переход к задаче
TaskProcs: 	.dw Idle				; [00] 
			.dw Send			; [01] 
			.dw SetDefMode			; [02] 
			.dw CheckADC			; [03] 
			.dw Convert			; [04] 
			.dw ScanButton			; [05]



; Подключены библиотеки работы с дисплеем и преобразования всякие
			.include "WH\lcd4.asm"
			.include "Math\hex2ascii.asm"
			

; Тексты режимов работы. Те что по английски пишутся как есть, а те которые по русски - кодами
; символов. Т.к. кодовая таблица HD44780 и ASCII в русском языке не совпадают.
t_Normal1:		.db	"Pinboard v1.1   "
t_Normal2:		.db "by DI HALT 2010 "

t_Terminal:		.db	66,179,111,227,32,99,32,191,101,112,188,184,189,97,187,97

t_Button1:		.db 72,97,182,97,191,97,32,186,189,111,190,186,97,32,32,32
t_Button2:		.db 45,72,111,188,101,112,32,186,189,111,190,186,184,32,32,0

t_ADC1:			.db 65,225,168,44,32,186,97,189,97,187,32,48,32,32,32,32
t_ADC2:			.db 32,45,32,164,189,97,192,101,189,184,101,32,32,32
