			.include "m168Pdef.inc"	; Используем ATMega8

                        .include "config.asm"
			.include "macro.asm"	; Все макросы у нас тут



;============SSEG=============================================================
			.DSEG
Mode:		.byte					1		; Переменная режима отображения
			.equ	m_Normal	=0			; Показ логотипа
			.equ	m_Terminal	=1			; Показ минитерминала
			.equ	m_ADC		=2			; Показ данных АЦП
			.equ	m_Button	=3			; Показ имени нажатой кнопки

ADC_Data:	.byte					1		; Тут складируются данные АЦП
ADC_OLD:	.byte					1		; Тут хранится предыдущее значение данных АЦП



; Очереди операционной системы
		.equ TaskQueueSize 		= 20				; Размер очереди задач
TaskQueue: 	.byte					TaskQueueSize 		; Адрес очереди задач в SRAM
			
		.equ TimersPoolSize 	= 20				; Количество таймеров
TimersPool:	.byte 					TimersPoolSize*3	; Адреса информации о таймерах (очередь)


;===========CSEG==============================================================
			.include "vectors.asm"	; Все вектора прерываний спрятаны в этом файле

			.ORG	INT_VECTORS_SIZE		; Конец таблицы прерываний


;=============================================================================!
; Interrupts procs ===========================================================!
;=============================================================================!
; Output Compare 2 interrupt 
; Main Timer Service - Служба Таймеров Ядра РТОС - Обработчик прерывания
OutComp2Int:
			TimerService				; Служба таймера RTOS 
			RETI						; выходим из прерывания

;.............................................................................

;Прерывания от пришедшего байта в UART
RX_OK:		PUSH 	OSRG
			IN 		OSRG,SREG			; Save Sreg
			PUSH 	OSRG

			LDS		OSRG,UDR0
			STS		UDR_I,OSRG

;			SetTask			TS_Terminal

			POP 	OSRG				; Восстанавливаем регистры
			OUT 	SREG,OSRG			; 
			POP 	OSRG
			RETI						; Выходим из прерывания
;=============================================================================!
; Main code ==================================================================!
;=============================================================================!
Reset:		INIT_STACK RAMEND								

			.include "init.asm"				; Все инициализации тут.


; Запуск фоновых процессов
Background:	
			RCALL	Send				; Отсыл байт в UART 
			

Main:		SEI								; Разрешаем прерывания.

			wdr								; Reset Watch DOG (Если не "погладить" "собаку". то она устроит конец света в виде reset для процессора)
			rcall 	ProcessTaskQueue		; Обработка очереди процессов
			rcall 	Idle					; Простой Ядра
											
			RJMP 	Main					; Основной цикл микроядра РТОС

;=============================================================================
;Tasks
;=============================================================================
Idle:		RET		; Простой ядра. Не используется

;-----------------------------------------------------------------------------
; Задача отсылки данных через терминал. Раз в 50мс шлет байт который считало АЦП
Send:
        SetTimerTask TS_Send,50		; Самозацикливаем задачу через диспетчер таймеров
        lds OSRG,ADC_Data			; Загрузить байт из переменной ADC_DATA
        sts UDR0,OSRG				; Отправить его через USART 
        ret

;=============================================================================
; RTOS Here
;=============================================================================
; Это область определения адресов и индексов задач. Порядок должен быть одинаковым, от этого
; критично зависит работа ОС

        .include "kernel_def.asm"	; Подключаем настройки ядра
        .include "kernel.asm"		; Подклчюаем ядро ОС

; Индексы (номера) задач.
        .equ TS_Idle 			= 0
        .equ TS_Send 			= 1

; А это их адреса во флеше. ПО индексу вычисляется смещение в таблице адресов и происходит 
; Переход к задаче
TaskProcs:
        .dw Idle        ; [00] 
	.dw Send        ; [01] 
